<script>
const APPSCRIPT_URL = "あなたの最新GASのexec URL";
const TEAM_SIZE = 4;
const ROLE_NEEDS = { "征服者": 1, "破壊者": 1, "守護者": 1, "掌握者": 1 };

function normalizeTarget(fixedGoal, goal) {
  const f = (fixedGoal || "").trim();
  const g = (goal || "").trim();
  if (f === "お休み" || g === "お休み") return null;
  if (f.startsWith("既") || g.startsWith("既")) return null;
  if (f) return f;
  if (!g) return "64位";
  return g;
}
function isFree(fixedGoal, goal) {
  const f = (fixedGoal || "").trim();
  const g = (goal || "").trim();
  return f === "フリー枠" || g === "フリー枠";
}
function teamState(team) {
  const roleCount = {};
  let total = 0;
  team.forEach(m => {
    total += m.skill;
    roleCount[m.role] = (roleCount[m.role] || 0) + 1;
  });
  let lackSum = 0;
  for (const r in ROLE_NEEDS) lackSum += Math.max(0, ROLE_NEEDS[r] - (roleCount[r] || 0));
  return { total, lackSum };
}
function upgradeTeamsByFree(teams, free) {
  const freeByRole = {};
  free.forEach(p => (freeByRole[p.role] ??= []).push(p));
  for (const r in freeByRole) freeByRole[r].sort((a,b)=> b.skill - a.skill);

  for (const team of teams) {
    for (const role in ROLE_NEEDS) {
      const pool = freeByRole[role];
      if (!pool?.length) continue;

      const sameRole = team.map((m,i)=>({m,i})).filter(x => x.m.role === role);
      if (!sameRole.length) continue;

      sameRole.sort((a,b)=> a.m.skill - b.m.skill);
      const weakest = sameRole[0];
      const strongestFree = pool[0];
      if (strongestFree.skill > weakest.m.skill) {
        team[weakest.i] = strongestFree;
        pool.shift();
      }
    }
  }

  const remaining = [];
  for (const r in freeByRole) remaining.push(...freeByRole[r]);
  return remaining;
}
function buildTeams(players) {
  const byTarget = new Map();
  let free = [];
  players.forEach(p => p.free ? free.push(p) : (byTarget.get(p.finalTarget) ?? byTarget.set(p.finalTarget, []).get(p.finalTarget)).push(p));

  const result = new Map();
  for (const [target, members] of byTarget.entries()) {
    members.sort((a,b)=> b.skill - a.skill);
    const teamCount = Math.max(1, Math.ceil(members.length / TEAM_SIZE));
    const teams = Array.from({length: teamCount}, ()=>[]);
    members.forEach((m,i)=> teams[i % teamCount].push(m));

    // free補完
    for (let i=0; i<free.length; i++) {
      const p = free[i];
      let bestIdx = -1, bestScore = -Infinity;
      teams.forEach((t,idx)=>{
        if (t.length >= TEAM_SIZE) return;
        const before = teamState(t);
        const after = teamState(t.concat([p]));
        const score = (before.lackSum - after.lackSum) * 100 + (after.total - before.total);
        if (score > bestScore) { bestScore = score; bestIdx = idx; }
      });
      if (bestIdx !== -1) { teams[bestIdx].push(p); free.splice(i,1); i--; }
    }

    // 置換強化
    free = upgradeTeamsByFree(teams, free);
    result.set(target, teams);
  }
  return { grouped: result, remainingFree: free };
}

document.getElementById("fetchBtn").addEventListener("click", async () => {
  const btn = document.getElementById("fetchBtn");
  const resultArea = document.getElementById("resultArea");
  btn.disabled = true;
  btn.innerText = "取得中...";
  resultArea.innerHTML = "";

  try {
    const res = await fetch(APPSCRIPT_URL, { cache: "no-store" });
    const text = await res.text();

    let data;
    try {
      data = JSON.parse(text);
    } catch {
      resultArea.innerHTML = `<div class="warn"><b>GASがJSON以外を返しました</b><br><pre style="white-space:pre-wrap;">${text.slice(0, 1500)}</pre></div>`;
      return;
    }

    // GASがエラーJSONを返した場合
    if (data && data.ok === false) {
      resultArea.innerHTML = `<div class="warn"><b>GASエラー</b><br><pre style="white-space:pre-wrap;">${data.error}</pre></div>`;
      return;
    }

    if (!Array.isArray(data) || data.length === 0) {
      resultArea.innerHTML = `<div class="warn"><b>データが0件です</b><br>ヘッダー行/データ開始行/列名を確認してください。</div>`;
      return;
    }

    const players = data.map(r => {
      const name = String(r.name || "").trim();
      const role = String(r.job || "").trim();
      const skill = Number(r.power) || 0;
      const fixedGoal = String(r.fixedGoal || "").trim();
      const goal = String(r.goal || "").trim();
      return { name, role, skill, finalTarget: normalizeTarget(fixedGoal, goal), free: isFree(fixedGoal, goal) };
    }).filter(p => p.name && p.role && Number.isFinite(p.skill) && p.finalTarget !== null);

    if (players.length === 0) {
      resultArea.innerHTML = `<div class="warn"><b>表示できる人が0人です</b><br>列値（名前/職業/目標）が空になっていないか確認してください。</div>`;
      return;
    }

    const { grouped, remainingFree } = buildTeams(players);

    for (const [target, teams] of grouped.entries()) {
      const h = document.createElement("div");
      h.style.margin = "20px 0 10px";
      h.style.fontWeight = "bold";
      h.textContent = `目標：${target}`;
      resultArea.appendChild(h);

      teams.forEach((team,i)=>{
        const div = document.createElement("div");
        div.className = "team-card";
        div.innerHTML = `
          <div class="team-title">チーム ${i+1}</div>
          <ul>${team.map(m => `<li class="member">${m.name}（${m.role} / ${m.skill}）</li>`).join("")}</ul>
        `;
        resultArea.appendChild(div);
      });
    }

    if (remainingFree.length) {
      const warn = document.createElement("div");
      warn.className = "warn";
      warn.innerHTML = `<b>未使用のフリー枠：</b><br>${remainingFree.map(m => `${m.name}（${m.role} / ${m.skill}）`).join("<br>")}`;
      resultArea.appendChild(warn);
    }

  } catch (e) {
    resultArea.innerHTML = `<div class="warn"><b>通信エラー</b><br><pre style="white-space:pre-wrap;">${String(e)}</pre></div>`;
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.innerText = "スプレッドシートから取得・振り分け";
  }
});
</script>
