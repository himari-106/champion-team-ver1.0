<script>
  // あなたの Apps Script WebアプリURL（そのまま）
  const APPSCRIPT_URL = "https://script.google.com/macros/s/AKfycbz_tR2YSGwbbONM1CKEX-0UypzM7OTSUIKaev1Ubk4XSldx9mFGSAh_5fe7lfY0uZc9/exec";
  const TEAM_SIZE = 4;
  const ROLES = ["破壊者", "掌握者", "征服者", "守護者"];
  const FIXED_NONE = new Set(["", "なし", "-", "無所属", null, undefined]);

  // --- 小物関数 ---
  const byDesc = (key) => (a,b) => (b[key]||0)-(a[key]||0);
  const byAscPower = (a,b) => (a.power||0)-(b.power||0);
  const clone = x => JSON.parse(JSON.stringify(x));
  const groupBy = (arr, keyFn) => arr.reduce((m, x) => {
    const k = keyFn(x);
    (m[k] = m[k] || []).push(x);
    return m;
  }, {});

  function makeTeam(goalLabel) {
    return { members: [], power: 0, roleCounts: {}, goal: goalLabel, notes: [] };
  }
  function addMember(team, m) {
    team.members.push(m);
    team.power += m.power || 0;
    team.roleCounts[m.job] = (team.roleCounts[m.job] || 0) + 1;
  }
  function hasRole(team, role) {
    return (team.roleCounts[role] || 0) > 0;
  }
  function missingRoles(team) {
    return ROLES.filter(r => !hasRole(team, r));
  }

  // 固定チームグループを抽出
  function buildFixedGroups(members) {
    const map = new Map();
    members.forEach(m => {
      const key = (m.fixed || "").trim();
      if (FIXED_NONE.has(key)) return;
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(m);
    });
    const groups = [];
    for (const [name, arr] of map.entries()) {
      const avgPower = arr.reduce((s, x) => s + (x.power||0), 0) / Math.max(1, arr.length);
      const roles = arr.map(x => x.job);
      groups.push({ name, size: arr.length, avgPower, roles, members: arr });
    }
    // 強い固定から先に配置（調整しやすい）
    groups.sort((a,b)=> b.avgPower - a.avgPower);
    return groups;
  }

  // 固定チームを配置（役職被りをなるべく避け、総戦力の低いチーム優先）
  function placeFixedGroups(teams, groups, warnings) {
    for (const g of groups) {
      if (g.size > TEAM_SIZE) {
        warnings.push(`固定チーム「${g.name}」が ${g.size} 人で4人上限を超えています。条件上そのままの固定は不可。`);
        continue; // そのままでは入れられないのでスキップ（要データ側調整）
      }
      let best = null;
      teams.forEach((t, idx) => {
        if (t.members.length + g.size > TEAM_SIZE) return;
        // 役職衝突数（すでにいる役職と被る数）
        const conflicts = g.roles.reduce((c, r) => c + (hasRole(t, r) ? 1 : 0), 0);
        // チームの総戦力（低い方を優先）
        const score = { idx, conflicts, power: t.power, capacity: TEAM_SIZE - t.members.length };
        if (!best ||
            score.conflicts < best.conflicts ||
            (score.conflicts === best.conflicts && score.power < best.power) ||
            (score.conflicts === best.conflicts && score.power === best.power && score.capacity > best.capacity)) {
          best = score;
        }
      });
      if (!best) {
        warnings.push(`固定チーム「${g.name}」を入れる空き枠がありません。`);
        continue;
      }
      const t = teams[best.idx];
      // 固定内に役職重複がある場合の注記
      const uniqueCount = new Set(g.roles).size;
      if (uniqueCount < g.roles.length) {
        t.notes.push(`固定「${g.name}」内で同役職が重複（各1人条件と両立しない可能性）。`);
      }
      g.members.forEach(m => addMember(t, m));
    }
  }

  // 役職ごとの人リスト（固定チーム以外）
  function buildRolePools(members, assignedIds) {
    const pools = new Map();
    ROLES.forEach(r => pools.set(r, []));
    members.forEach(m => {
      if (assignedIds.has(m._id)) return;
      if (!pools.has(m.job)) pools.set(m.job, []);
      pools.get(m.job).push(m);
    });
    ROLES.forEach(r => pools.get(r).sort(byDesc("power"))); // 強い順
    return pools;
  }

  // 欠けている役職を優先配分（総戦力が低いチームから）
  function fillMissingRoles(teams, pools) {
    // まず各チームに1人ずつ揃える
    teams.sort(byAscPower);
    for (const t of teams) {
      for (const role of ROLES) {
        if (t.members.length >= TEAM_SIZE) break;
        if (!hasRole(t, role) && pools.get(role)?.length) {
          addMember(t, pools.get(role).shift());
        }
      }
    }
  }

  // 残り枠を総戦力の低いチームから埋める（どの役職でも）
  function fillRest(teams, pools) {
    // 余りの人たち
    const leftovers = [];
    for (const role of ROLES) leftovers.push(...(pools.get(role) || []));
    leftovers.sort(byDesc("power"));
    for (const m of leftovers) {
      const candidate = teams
        .filter(t => t.members.length < TEAM_SIZE)
        .sort(byAscPower)[0];
      if (!candidate) break;
      addMember(candidate, m);
    }
  }

  // 目標順位（goal）ごとに配分
  function buildTeamsForGoal(goalLabel, members, warnings) {
    // _idを振る（内部管理用）
    members.forEach((m, i) => m._id = `${goalLabel}-${i}-${m.name}`);

    const teamCount = Math.ceil(members.length / TEAM_SIZE) || 1;
    const teams = Array.from({length: teamCount}, () => makeTeam(goalLabel));

    // 固定チーム配置
    const fixedGroups = buildFixedGroups(members);
    const assigned = new Set();
    placeFixedGroups(teams, fixedGroups, warnings);
    fixedGroups.forEach(g => g.members.forEach(m => assigned.add(m._id)));

    // 役職プール（固定以外）
    const pools = buildRolePools(members, assigned);

    // 欠け役職を優先的に充当
    fillMissingRoles(teams, pools);

    // まだ枠が余っていれば、総戦力の低いチームから埋める
    fillRest(teams, pools);

    // 最終チェック：人数が4未満のチームが残れば警告
    for (const [i,t] of teams.entries()) {
      if (t.members.length !== TEAM_SIZE) {
        warnings.push(`目標「${goalLabel}」のチーム${i+1}が ${t.members.length} 人です（4人に満たない/超過）。元データの人数や固定・役職分布をご確認ください。`);
      }
    }
    return teams;
  }

  // 画面描画（固定チーム名は非表示）
  function render(groups) {
    const resultArea = document.getElementById("resultArea");
    resultArea.innerHTML = "";

    groups.forEach(({ goal, teams }) => {
      // 目標順位見出し
      const h = document.createElement("div");
      h.style.margin = "8px 0 6px";
      h.style.fontWeight = "bold";
      h.textContent = `目標順位: ${goal}`;
      resultArea.appendChild(h);

      teams.forEach((team, idx) => {
        const div = document.createElement("div");
        div.className = "team-card";
        const items = team.members.map(m => `
          <li class="member">
            ${m.name}（${m.job}）<br>
            戦力: ${m.power}${m.goal ? ` ／ 目標順位: ${m.goal}` : ""}
          </li>`).join("");
        const noteHtml = team.notes.length ? `<div style="color:#888; font-size:0.85em; margin-top:6px;">※${team.notes.join(" / ")}</div>` : "";
        div.innerHTML = `
          <div class="team-title">チーム ${idx + 1}</div>
          <ul>${items}</ul>
          ${noteHtml}
        `;
        resultArea.appendChild(div);
      });
    });
  }

  document.getElementById("fetchBtn").addEventListener("click", async () => {
    const btn = document.getElementById("fetchBtn");
    btn.disabled = true;
    btn.innerText = "取得中...";

    try {
      const res = await fetch(`${APPSCRIPT_URL}?t=${Date.now()}`);
      const text = await res.text();
      const raw = JSON.parse(text);

      // 正規化
      const data = raw
        .filter(p => p.name && p.job && p.goal !== undefined) // 目標順位が必須
        .map(p => ({
          name: String(p.name).trim(),
          job: String(p.job).trim(),                     // 破壊者/掌握者/征服者/守護者
          power: Number(p.power) || 0,                   // 数値化
          goal: String(p.goal).trim(),                   // 同一文字列でグルーピング
          fixed: (p.team ?? "").toString().trim()        // 固定チーム名（表示しない）
        }));

      // 目標順位ごとに分ける
      const byGoal = groupBy(data, x => x.goal);
      const goalLabels = Object.keys(byGoal);
      const allGroups = [];
      const warnings = [];

      goalLabels.forEach(goal => {
        const members = clone(byGoal[goal]);
        // まず役職の表記ゆれ対策（全角空白除去など）
        members.forEach(m => { m.job = m.job.replace(/\s+/g, ""); });
        // 各ゴールで配分
        const teams = buildTeamsForGoal(goal, members, warnings);
        allGroups.push({ goal, teams });
      });

      if (warnings.length) {
        console.warn("配分に関する警告:", warnings);
      }

      render(allGroups);
    } catch (err) {
      alert("スプレッドシートの取得・配分でエラーが発生しました。コンソールをご確認ください。");
      console.error(err);
    }

    btn.disabled = false;
    btn.innerText = "スプレッドシートから取得・振り分け";
  });
</script>
